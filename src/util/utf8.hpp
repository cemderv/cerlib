// Copyright 2006-2016 Nemanja Trifunovic

/*
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

// Modified for use in cerlib.

#pragma once

#include <cstring>
#include <iterator>
#include <stdexcept>
#include <string>

namespace utf8
{
// Helper code - not intended to be directly called by the library users. May be changed at any time
namespace internal
{
// Unicode constants
// Leading (high) surrogates: 0xd800 - 0xdbff
// Trailing (low) surrogates: 0xdc00 - 0xdfff
constexpr char16_t lead_surrogate_min  = 0xd800u;
constexpr char16_t lead_surrogate_max  = 0xdbffu;
constexpr char16_t trail_surrogate_min = 0xdc00u;
constexpr char16_t trail_surrogate_max = 0xdfffu;
constexpr char16_t lead_offset         = 0xd7c0u; // LEAD_SURROGATE_MIN - (0x10000 >> 10)
constexpr char32_t surrogate_offset =
    0xfca02400u; // 0x10000u - (LEAD_SURROGATE_MIN << 10) - TRAIL_SURROGATE_MIN

// Maximum valid value for a Unicode code point
constexpr char32_t code_point_max = 0x0010ffffu;

template <typename OctetType>
auto mask8(OctetType oc) -> char8_t
{
    return static_cast<char8_t>(0xff & oc);
}

template <typename U16Type>
auto mask16(U16Type oc) -> char16_t
{
    return static_cast<char16_t>(0xffff & oc);
}

template <typename OctetType>
auto is_trail(OctetType oc) -> bool
{
    return ((internal::mask8(oc) >> 6) == 0x2);
}

inline auto is_lead_surrogate(char32_t cp) -> bool
{
    return (cp >= lead_surrogate_min && cp <= lead_surrogate_max);
}

inline auto is_trail_surrogate(char32_t cp) -> bool
{
    return (cp >= trail_surrogate_min && cp <= trail_surrogate_max);
}

inline auto is_surrogate(char32_t cp) -> bool
{
    return (cp >= lead_surrogate_min && cp <= trail_surrogate_max);
}

inline auto is_code_point_valid(char32_t cp) -> bool
{
    return (cp <= code_point_max && !is_surrogate(cp));
}

inline auto is_in_bmp(char32_t cp) -> bool
{
    return cp < char32_t(0x10000);
}

template <typename OctetIterator>
auto sequence_length(OctetIterator lead_it) -> int
{
    const char8_t lead = internal::mask8(*lead_it);
    if (lead < 0x80)
        return 1;
    if ((lead >> 5) == 0x6)
        return 2;
    if ((lead >> 4) == 0xe)
        return 3;
    if ((lead >> 3) == 0x1e)
        return 4;

    return 0;
}

inline auto is_overlong_sequence(char32_t cp, int length) -> bool
{
    if (cp < 0x80)
    {
        if (length != 1)
        {
            return true;
        }
    }
    else if (cp < 0x800)
    {
        if (length != 2)
        {
            return true;
        }
    }
    else if (cp < 0x10000)
    {
        if (length != 3)
        {
            return true;
        }
    }
    return false;
}

enum utf_error
{
    UTF8_OK,
    NOT_ENOUGH_ROOM,
    INVALID_LEAD,
    INCOMPLETE_SEQUENCE,
    OVERLONG_SEQUENCE,
    INVALID_CODE_POINT
};

/// Helper for get_sequence_x
template <typename OctetIterator>
auto increase_safely(OctetIterator& it, const OctetIterator end) -> utf_error
{
    if (++it == end)
    {
        return NOT_ENOUGH_ROOM;
    }

    if (!internal::is_trail(*it))
    {
        return INCOMPLETE_SEQUENCE;
    }

    return UTF8_OK;
}

#define UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(IT, END)                                             \
    {                                                                                              \
        utf_error ret = increase_safely(IT, END);                                                  \
        if (ret != UTF8_OK)                                                                        \
            return ret;                                                                            \
    }

/// get_sequence_x functions decode utf-8 sequences of the length x
template <typename OctetIterator>
auto get_sequence_1(OctetIterator& it, OctetIterator end, char32_t& code_point) -> utf_error
{
    if (it == end)
    {
        return NOT_ENOUGH_ROOM;
    }

    code_point = internal::mask8(*it);

    return UTF8_OK;
}

template <typename OctetIterator>
auto get_sequence_2(OctetIterator& it, OctetIterator end, char32_t& code_point) -> utf_error
{
    if (it == end)
    {
        return NOT_ENOUGH_ROOM;
    }

    code_point = internal::mask8(*it);

    UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(it, end)

    code_point = ((code_point << 6) & 0x7ff) + ((*it) & 0x3f);

    return UTF8_OK;
}

template <typename OctetIterator>
auto get_sequence_3(OctetIterator& it, OctetIterator end, char32_t& code_point) -> utf_error
{
    if (it == end)
    {
        return NOT_ENOUGH_ROOM;
    }

    code_point = internal::mask8(*it);

    UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(it, end)

    code_point = ((code_point << 12) & 0xffff) + ((internal::mask8(*it) << 6) & 0xfff);

    UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(it, end)

    code_point += (*it) & 0x3f;

    return UTF8_OK;
}

template <typename OctetIterator>
auto get_sequence_4(OctetIterator& it, OctetIterator end, char32_t& code_point) -> utf_error
{
    if (it == end)
    {
        return NOT_ENOUGH_ROOM;
    }

    code_point = internal::mask8(*it);

    UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(it, end)

    code_point = ((code_point << 18) & 0x1fffff) + ((internal::mask8(*it) << 12) & 0x3ffff);

    UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(it, end)

    code_point += (internal::mask8(*it) << 6) & 0xfff;

    UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(it, end)

    code_point += (*it) & 0x3f;

    return UTF8_OK;
}

#undef UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR

template <typename OctetIterator>
auto validate_next(OctetIterator& it, OctetIterator end, char32_t& code_point) -> utf_error
{
    if (it == end)
    {
        return NOT_ENOUGH_ROOM;
    }

    // Save the original value of it so we can go back in case of failure
    // Of course, it does not make much sense with i.e. stream iterators
    OctetIterator original_it = it;

    char32_t cp = 0;
    // Determine the sequence length based on the lead octet
    const int length = internal::sequence_length(it);

    // Get trail octets and calculate the code point
    utf_error err = UTF8_OK;
    switch (length)
    {
        case 0: return INVALID_LEAD;
        case 1: err = internal::get_sequence_1(it, end, cp); break;
        case 2: err = internal::get_sequence_2(it, end, cp); break;
        case 3: err = internal::get_sequence_3(it, end, cp); break;
        case 4: err = internal::get_sequence_4(it, end, cp); break;
        default: break;
    }

    if (err == UTF8_OK)
    {
        // Decoding succeeded. Now, security checks...
        if (is_code_point_valid(cp))
        {
            if (!is_overlong_sequence(cp, length))
            {
                // Passed! Return here.
                code_point = cp;
                ++it;
                return UTF8_OK;
            }

            err = OVERLONG_SEQUENCE;
        }
        else
        {
            err = INVALID_CODE_POINT;
        }
    }

    // Failure branch - restore the original value of the iterator
    it = original_it;

    return err;
}

template <typename OctetIterator>
auto validate_next(OctetIterator& it, OctetIterator end) -> utf_error
{
    char32_t ignored = 0;
    return internal::validate_next(it, end, ignored);
}

template <typename WordIterator>
auto validate_next16(WordIterator& it, WordIterator end, char32_t& code_point) -> utf_error
{
    if (it == end)
    {
        return NOT_ENOUGH_ROOM;
    }
    // Save the original value of it so we can go back in case of failure
    // Of course, it does not make much sense with i.e. stream iterators
    WordIterator original_it = it;

    utf_error err = UTF8_OK;

    const char16_t first_word = *it++;
    if (!is_surrogate(first_word))
    {
        code_point = first_word;
        return UTF8_OK;
    }

    if (it == end)
    {
        err = NOT_ENOUGH_ROOM;
    }
    else if (is_lead_surrogate(first_word))
    {
        const char16_t second_word = *it++;
        if (is_trail_surrogate(second_word))
        {
            code_point = (first_word << 10) + second_word + surrogate_offset;
            return UTF8_OK;
        }

        err = INCOMPLETE_SEQUENCE;
    }
    else
    {
        err = INVALID_LEAD;
    }

    // error branch
    it = original_it;

    return err;
}

// Internal implementation of both checked and unchecked append() function
// This function will be invoked by the overloads below, as they will know
// the OctetType.
template <typename OctetIterator, typename OctetType>
auto append(char32_t cp, OctetIterator result) -> OctetIterator
{
    if (cp < 0x80)
    {
        // one octet
        *(result++) = static_cast<OctetType>(cp);
    }
    else if (cp < 0x800)
    {
        // two octets
        *(result++) = static_cast<OctetType>((cp >> 6) | 0xc0);
        *(result++) = static_cast<OctetType>((cp & 0x3f) | 0x80);
    }
    else if (cp < 0x10000)
    {
        // three octets
        *(result++) = static_cast<OctetType>((cp >> 12) | 0xe0);
        *(result++) = static_cast<OctetType>(((cp >> 6) & 0x3f) | 0x80);
        *(result++) = static_cast<OctetType>((cp & 0x3f) | 0x80);
    }
    else
    {
        // four octets
        *(result++) = static_cast<OctetType>((cp >> 18) | 0xf0);
        *(result++) = static_cast<OctetType>(((cp >> 12) & 0x3f) | 0x80);
        *(result++) = static_cast<OctetType>(((cp >> 6) & 0x3f) | 0x80);
        *(result++) = static_cast<OctetType>((cp & 0x3f) | 0x80);
    }

    return result;
}

// One of the following overloads will be invoked from the API calls

// A simple (but dangerous) case: the caller appends byte(s) to a char array
inline auto append(char32_t cp, char* result) -> char*
{
    return append<char*, char>(cp, result);
}

// Hopefully, most common case: the caller uses back_inserter
// i.e. append(cp, std::back_inserter(str));
template <typename ContainerType>
auto append(char32_t cp, std::back_insert_iterator<ContainerType> result)
    -> std::back_insert_iterator<ContainerType>
{
    return append<std::back_insert_iterator<ContainerType>, typename ContainerType::value_type>(
        cp,
        result);
}

// The caller uses some other kind of output operator - not covered above
// Note that in this case we are not able to determine OctetType
// so we assume it's char8_t; that can cause a conversion warning if we are wrong.
template <typename OctetIterator>
auto append(char32_t cp, OctetIterator result) -> OctetIterator
{
    return append<OctetIterator, char8_t>(cp, result);
}

// Internal implementation of both checked and unchecked append16() function
// This function will be invoked by the overloads below, as they will know
// the word_type.
template <typename WordIterator, typename word_type>
auto append16(char32_t cp, WordIterator result) -> WordIterator
{
    if (is_in_bmp(cp))
    {
        *(result++) = static_cast<word_type>(cp);
    }
    else
    {
        // Code points from the supplementary planes are encoded via surrogate pairs
        *(result++) = static_cast<word_type>(lead_offset + (cp >> 10));
        *(result++) = static_cast<word_type>(trail_surrogate_min + (cp & 0x3FF));
    }

    return result;
}

// Hopefully, most common case: the caller uses back_inserter
// i.e. append16(cp, std::back_inserter(str));
template <typename container_type>
auto append16(char32_t cp, std::back_insert_iterator<container_type> result)
    -> std::back_insert_iterator<container_type>
{
    return append16<std::back_insert_iterator<container_type>, typename container_type::value_type>(
        cp,
        result);
}

// The caller uses some other kind of output operator - not covered above
// Note that in this case we are not able to determine word_type
// so we assume it's char16_t; that can cause a conversion warning if we are wrong.
template <typename word_iterator>
auto append16(char32_t cp, word_iterator result) -> word_iterator
{
    return append16<word_iterator, char16_t>(cp, result);
}

} // namespace internal

/// The library API - functions intended to be called by the users

// Byte order mark
constexpr char8_t bom[] = {0xef, 0xbb, 0xbf};

template <typename OctetIterator>
auto find_invalid(OctetIterator start, OctetIterator end) -> OctetIterator
{
    OctetIterator result = start;

    while (result != end)
    {
        if (internal::validate_next(result, end) != internal::UTF8_OK)
        {
            return result;
        }
    }

    return result;
}

inline auto find_invalid(const char* str) -> const char*
{
    const char* end = str + std::strlen(str);
    return find_invalid(str, end);
}

inline auto find_invalid(const std::string& s) -> std::size_t
{
    std::string::const_iterator invalid = find_invalid(s.begin(), s.end());
    return (invalid == s.end()) ? std::string::npos : static_cast<std::size_t>(invalid - s.begin());
}

template <typename OctetIterator>
inline auto is_valid(OctetIterator start, OctetIterator end) -> bool
{
    return (utf8::find_invalid(start, end) == end);
}

inline auto is_valid(const char* str) -> bool
{
    return (*(find_invalid(str)) == '\0');
}

inline auto is_valid(const std::string& s) -> bool
{
    return is_valid(s.begin(), s.end());
}

template <typename OctetIterator>
inline auto starts_with_bom(OctetIterator it, OctetIterator end) -> bool
{
    return (((it != end) && (internal::mask8(*it++)) == bom[0]) &&
            ((it != end) && (internal::mask8(*it++)) == bom[1]) &&
            ((it != end) && (internal::mask8(*it)) == bom[2]));
}

inline auto starts_with_bom(const std::string& s) -> bool
{
    return starts_with_bom(s.begin(), s.end());
}

// Exceptions that may be thrown from the library functions.
class InvalidCodePoint : public std::exception
{
    char32_t cp{};

  public:
    explicit InvalidCodePoint(char32_t codepoint)
        : cp(codepoint)
    {
    }

    auto what() const noexcept -> const char* override
    {
        return "Invalid code point";
    }

    auto code_point() const -> char32_t
    {
        return cp;
    }
};

class invalid_utf8 final : public std::exception
{
    char8_t m_u8;

  public:
    explicit invalid_utf8(char8_t u)
        : m_u8(u)
    {
    }

    explicit invalid_utf8(char c)
        : m_u8(static_cast<char8_t>(c))
    {
    }

    auto what() const noexcept -> const char* override
    {
        return "Invalid UTF-8";
    }

    auto utf8_octet() const -> char8_t
    {
        return m_u8;
    }
};

class invalid_utf16 final : public std::exception
{
    char16_t m_u16;

  public:
    explicit invalid_utf16(char16_t u)
        : m_u16(u)
    {
    }

    auto what() const noexcept -> const char* override
    {
        return "Invalid UTF-16";
    }

    auto utf16_word() const -> char16_t
    {
        return m_u16;
    }
};

class not_enough_room final : public std::exception
{
  public:
    auto what() const noexcept -> const char* override
    {
        return "Not enough space";
    }
};

/// The library API - functions intended to be called by the users

template <typename OctetIterator>
auto append(char32_t cp, OctetIterator result) -> OctetIterator
{
    if (!internal::is_code_point_valid(cp))
    {
        throw InvalidCodePoint(cp);
    }

    return internal::append(cp, result);
}

inline void append(char32_t cp, std::string& s)
{
    append(cp, std::back_inserter(s));
}

template <typename word_iterator>
auto append16(char32_t cp, word_iterator result) -> word_iterator
{
    if (!internal::is_code_point_valid(cp))
    {
        throw InvalidCodePoint(cp);
    }

    return internal::append16(cp, result);
}

template <typename OctetIterator, typename output_iterator>
auto replace_invalid(OctetIterator   start,
                     OctetIterator   end,
                     output_iterator out,
                     char32_t        replacement) -> output_iterator
{
    while (start != end)
    {
        auto sequence_start = start;

        switch (internal::validate_next(start, end))
        {
            case internal::UTF8_OK:
                for (OctetIterator it = sequence_start; it != start; ++it)
                {
                    *out++ = *it;
                }
                break;
            case internal::NOT_ENOUGH_ROOM:
                out   = utf8::append(replacement, out);
                start = end;
                break;
            case internal::INVALID_LEAD:
                out = utf8::append(replacement, out);
                ++start;
                break;
            case internal::INCOMPLETE_SEQUENCE:
            case internal::OVERLONG_SEQUENCE:
            case internal::INVALID_CODE_POINT:
                out = utf8::append(replacement, out);
                ++start;
                // just one replacement mark for the sequence
                while (start != end && internal::is_trail(*start))
                {
                    ++start;
                }
                break;
            default: break;
        }
    }
    return out;
}

template <typename OctetIterator, typename output_iterator>
auto replace_invalid(OctetIterator start, OctetIterator end, output_iterator out) -> output_iterator
{
    static const char32_t replacement_marker = internal::mask16(0xfffd);
    return utf8::replace_invalid(start, end, out, replacement_marker);
}

inline auto replace_invalid(const std::string& s, char32_t replacement) -> std::string
{
    std::string result;
    replace_invalid(s.begin(), s.end(), std::back_inserter(result), replacement);
    return result;
}

inline auto replace_invalid(const std::string& s) -> std::string
{
    std::string result;
    replace_invalid(s.begin(), s.end(), std::back_inserter(result));
    return result;
}

template <typename OctetIterator>
auto next(OctetIterator& it, OctetIterator end) -> char32_t
{
    char32_t cp = 0;
    switch (internal::validate_next(it, end, cp))
    {
        case internal::UTF8_OK: break;
        case internal::NOT_ENOUGH_ROOM: throw not_enough_room();
        case internal::INVALID_LEAD:
        case internal::INCOMPLETE_SEQUENCE:
        case internal::OVERLONG_SEQUENCE: throw invalid_utf8(static_cast<char8_t>(*it));
        case internal::INVALID_CODE_POINT: throw InvalidCodePoint(cp);
        default: break;
    }
    return cp;
}

template <typename word_iterator>
auto next16(word_iterator& it, word_iterator end) -> char32_t
{
    char32_t cp       = 0;
    auto     err_code = internal::validate_next16(it, end, cp);

    if (err_code == internal::NOT_ENOUGH_ROOM)
    {
        throw not_enough_room();
    }

    return cp;
}

template <typename OctetIterator>
auto peek_next(OctetIterator it, OctetIterator end) -> char32_t
{
    return utf8::next(it, end);
}

template <typename OctetIterator>
auto prior(OctetIterator& it, OctetIterator start) -> char32_t
{
    // can't do much if it == start
    if (it == start)
    {
        throw not_enough_room();
    }

    OctetIterator end = it;

    // Go back until we hit either a lead octet or start
    while (internal::is_trail(*(--it)))
    {
        if (it == start)
        {
            throw invalid_utf8(*it); // error - no lead byte in the sequence
        }
    }

    return utf8::peek_next(it, end);
}

template <typename OctetIterator, typename distance_type>
void advance(OctetIterator& it, distance_type n, OctetIterator end)
{
    const distance_type zero(0);
    if (n < zero)
    {
        // backward
        for (distance_type i = n; i < zero; ++i)
        {
            utf8::prior(it, end);
        }
    }
    else
    {
        // forward
        for (distance_type i = zero; i < n; ++i)
        {
            utf8::next(it, end);
        }
    }
}

template <typename OctetIterator>
auto distance(OctetIterator first, OctetIterator last) ->
    typename std::iterator_traits<OctetIterator>::difference_type
{
    typename std::iterator_traits<OctetIterator>::difference_type dist;
    for (dist = 0; first < last; ++dist)
    {
        utf8::next(first, last);
    }
    return dist;
}

template <typename u16bit_iterator, typename OctetIterator>
auto utf16to8(u16bit_iterator start, u16bit_iterator end, OctetIterator result) -> OctetIterator
{
    while (start != end)
    {
        char32_t cp = internal::mask16(*start++);
        // Take care of surrogate pairs first
        if (internal::is_lead_surrogate(cp))
        {
            if (start != end)
            {
                const char32_t trail_surrogate = internal::mask16(*start++);
                if (internal::is_trail_surrogate(trail_surrogate))
                {
                    cp = (cp << 10) + trail_surrogate + internal::surrogate_offset;
                }
                else
                {
                    throw invalid_utf16(static_cast<char16_t>(trail_surrogate));
                }
            }
            else
            {
                throw invalid_utf16(static_cast<char16_t>(cp));
            }
        }
        // Lone trail surrogate
        else if (internal::is_trail_surrogate(cp))
        {
            throw invalid_utf16(static_cast<char16_t>(cp));
        }

        result = utf8::append(cp, result);
    }
    return result;
}

template <typename u16bit_iterator, typename OctetIterator>
auto utf8to16(OctetIterator start, OctetIterator end, u16bit_iterator result) -> u16bit_iterator
{
    while (start < end)
    {
        const char32_t cp = utf8::next(start, end);
        if (cp > 0xffff)
        { // make a surrogate pair
            *result++ = static_cast<char16_t>((cp >> 10) + internal::lead_offset);
            *result++ = static_cast<char16_t>((cp & 0x3ff) + internal::trail_surrogate_min);
        }
        else
        {
            *result++ = static_cast<char16_t>(cp);
        }
    }
    return result;
}

template <typename OctetIterator, typename U32bitIterator>
auto utf32to8(U32bitIterator start, U32bitIterator end, OctetIterator result) -> OctetIterator
{
    while (start != end)
    {
        result = utf8::append(*(start++), result);
    }

    return result;
}

template <typename OctetIterator, typename u32bit_iterator>
auto utf8to32(OctetIterator start, OctetIterator end, u32bit_iterator result) -> u32bit_iterator
{
    while (start < end)
    {
        (*result++) = utf8::next(start, end);
    }

    return result;
}

// The iterator class
template <typename OctetIterator>
class iterator
{
    OctetIterator it;
    OctetIterator range_start;
    OctetIterator range_end;

  public:
    using value_type        = char32_t;
    using pointer           = char32_t*;
    using reference         = char32_t&;
    using difference_type   = std::ptrdiff_t;
    using iterator_category = std::bidirectional_iterator_tag;

    iterator() = default;

    explicit iterator(const OctetIterator& octet_it,
                      const OctetIterator& rangestart,
                      const OctetIterator& rangeend)
        : it(octet_it)
        , range_start(rangestart)
        , range_end(rangeend)
    {
        if (it < range_start || it > range_end)
        {
            throw std::out_of_range("Invalid utf-8 iterator position");
        }
    }
    // the default "big three" are OK
    auto base() const -> OctetIterator
    {
        return it;
    }
    auto operator*() const -> char32_t
    {
        OctetIterator temp = it;
        return utf8::next(temp, range_end);
    }
    auto operator==(const iterator& rhs) const -> bool
    {
        if (range_start != rhs.range_start || range_end != rhs.range_end)
        {
            throw std::logic_error("Comparing utf-8 iterators defined with different ranges");
        }
        return (it == rhs.it);
    }
    auto operator!=(const iterator& rhs) const -> bool
    {
        return !(operator==(rhs));
    }
    auto operator++() -> iterator&
    {
        utf8::next(it, range_end);
        return *this;
    }
    auto operator++(int) -> iterator
    {
        iterator temp = *this;
        utf8::next(it, range_end);
        return temp;
    }
    auto operator--() -> iterator&
    {
        utf8::prior(it, range_start);
        return *this;
    }
    auto operator--(int) -> iterator
    {
        iterator temp = *this;
        utf8::prior(it, range_start);
        return temp;
    }
}; // class iterator


inline auto utf16tou8(const std::u16string& s) -> std::u8string
{
    std::u8string result;
    utf16to8(s.begin(), s.end(), std::back_inserter(result));
    return result;
}

inline auto utf16tou8(std::u16string_view s) -> std::u8string
{
    std::u8string result;
    utf16to8(s.begin(), s.end(), std::back_inserter(result));
    return result;
}

inline auto utf8to16(const std::u8string& s) -> std::u16string
{
    std::u16string result;
    utf8to16(s.begin(), s.end(), std::back_inserter(result));
    return result;
}

inline auto utf8to16(const std::u8string_view& s) -> std::u16string
{
    std::u16string result;
    utf8to16(s.begin(), s.end(), std::back_inserter(result));
    return result;
}

inline auto utf32tou8(const std::u32string& s) -> std::u8string
{
    std::u8string result;
    utf32to8(s.begin(), s.end(), std::back_inserter(result));
    return result;
}

inline auto utf32tou8(const std::u32string_view& s) -> std::u8string
{
    std::u8string result;
    utf32to8(s.begin(), s.end(), std::back_inserter(result));
    return result;
}

inline auto utf8to32(const std::u8string& s) -> std::u32string
{
    std::u32string result;
    utf8to32(s.begin(), s.end(), std::back_inserter(result));
    return result;
}

inline auto utf8to32(const std::u8string_view& s) -> std::u32string
{
    std::u32string result;
    utf8to32(s.begin(), s.end(), std::back_inserter(result));
    return result;
}

inline auto find_invalid(const std::u8string& s) -> std::size_t
{
    const auto invalid = find_invalid(s.begin(), s.end());
    return (invalid == s.end()) ? std::string_view::npos
                                : static_cast<std::size_t>(invalid - s.begin());
}

inline auto is_valid(const std::u8string& s) -> bool
{
    return is_valid(s.begin(), s.end());
}

inline auto replace_invalid(const std::u8string& s, char32_t replacement) -> std::u8string
{
    std::u8string result;
    replace_invalid(s.begin(), s.end(), std::back_inserter(result), replacement);
    return result;
}

inline auto replace_invalid(const std::u8string& s) -> std::u8string
{
    std::u8string result;
    replace_invalid(s.begin(), s.end(), std::back_inserter(result));
    return result;
}

inline auto starts_with_bom(const std::u8string& s) -> bool
{
    return starts_with_bom(s.begin(), s.end());
}
} // namespace utf8
